// Code generated by re2c 3.1, DO NOT EDIT.
package cscan

func nextInclude(s *Scanner) *IncludeDirective {
	var tbag tokenBag

	buf := s.input[:s.softEnd]
	pos := s.pos

acceptToken:
	tokBegin, tokLine := pos, s.line

	{
		var yych byte
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\t':
			fallthrough
		case '\v', '\f':
			fallthrough
		case ' ':
			goto yy3
		case '\n':
			goto yy4
		case '\r':
			goto yy6
		case '"':
			goto yy7
		case '#':
			goto yy8
		case '\'':
			goto yy9
		case '/':
			goto yy10
		case '<':
			goto yy11
		case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
			fallthrough
		case '_':
			fallthrough
		case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
			goto yy12
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy18
			}
			goto yy1
		}
	yy1:
		pos++
	yy2:
		{
			tbag.push(tokUnspec, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy3:
		pos++
		{
			goto acceptToken
		}
	yy4:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\r':
			goto yy14
		default:
			goto yy5
		}
	yy5:
		{
			s.line++
			if includeDir := tbag.handleIncludeDirective(pos, s); includeDir != nil {
				s.softEnd, s.pos = len(buf), pos
				return includeDir
			}
			tbag.reset()
			goto acceptToken
		}
	yy6:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			goto yy14
		default:
			goto yy5
		}
	yy7:
		pos++
		{
			goto quotedString
		}
	yy8:
		pos++
		{
			tbag.push(tokHash, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy9:
		pos++
		{
			goto charLit
		}
	yy10:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '*':
			goto yy15
		case '/':
			goto yy16
		default:
			goto yy2
		}
	yy11:
		pos++
		{
			if tbag.count == 2 && tbag.isIncludeDirective() {
				goto angledString
			}
			tbag.push(tokUnspec, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy12:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			fallthrough
		case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
			fallthrough
		case '_':
			fallthrough
		case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
			goto yy12
		default:
			goto yy13
		}
	yy13:
		{
			tbag.push(tokIdentifier, tokBegin, pos, tokLine, s)
			if tbag.count == 2 {
				switch tbag.tokens[1].string(s) {
				case "include":
					tbag.tokens[1].kind = tokInclude
				case "include_next":
					tbag.tokens[1].kind = tokIncludeNext
				}
			}
			goto acceptToken
		}
	yy14:
		pos++
		goto yy5
	yy15:
		pos++
		{
			goto comment
		}
	yy16:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			fallthrough
		case '\r':
			goto yy17
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy17
			}
			goto yy16
		}
	yy17:
		{
			goto acceptToken
		}
	yy18:
		{
			s.softEnd, s.pos = len(buf), pos
			return tbag.handleIncludeDirective(pos, s)
		}
	}

comment:

	{
		var yych byte
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			goto yy22
		case '\r':
			goto yy24
		case '*':
			goto yy25
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy28
			}
			goto yy20
		}
	yy20:
		pos++
	yy21:
		{
			goto comment
		}
	yy22:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\r':
			goto yy26
		default:
			goto yy23
		}
	yy23:
		{
			s.line++
			goto comment
		}
	yy24:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			goto yy26
		default:
			goto yy23
		}
	yy25:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '/':
			goto yy27
		default:
			goto yy21
		}
	yy26:
		pos++
		goto yy23
	yy27:
		pos++
		{
			goto acceptToken
		}
	yy28:
		{
			s.reportError(errUnterminatedComment, tokBegin, tokLine)
			goto acceptToken
		}
	}

quotedString:

	{
		var yych byte
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			fallthrough
		case '\r':
			goto yy32
		case '"':
			goto yy33
		case '\\':
			goto yy34
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy36
			}
			goto yy30
		}
	yy30:
		pos++
	yy31:
		{
			goto quotedString
		}
	yy32:
		pos++
		{
			s.reportError(errUnterminatedQString, tokBegin, tokLine)
			tbag.push(tokUnterminatedQString, tokBegin, pos-1, tokLine, s)
			pos--
			goto acceptToken
		}
	yy33:
		pos++
		{
			tbag.push(tokQString, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy34:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '"':
			goto yy35
		default:
			goto yy31
		}
	yy35:
		pos++
		{
			goto quotedString
		}
	yy36:
		{
			s.reportError(errUnterminatedQString, tokBegin, tokLine)
			tbag.push(tokUnterminatedQString, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	}

charLit:

	{
		var yych byte
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			fallthrough
		case '\r':
			goto yy40
		case '\'':
			goto yy41
		case '\\':
			goto yy42
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy44
			}
			goto yy38
		}
	yy38:
		pos++
	yy39:
		{
			goto charLit
		}
	yy40:
		pos++
		{
			s.reportError(errUnterminatedCharLit, tokBegin, tokLine)
			tbag.push(tokUnspec, tokBegin, pos-1, tokLine, s)
			pos--
			goto acceptToken
		}
	yy41:
		pos++
		{
			tbag.push(tokUnspec, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy42:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\'':
			goto yy43
		default:
			goto yy39
		}
	yy43:
		pos++
		{
			goto charLit
		}
	yy44:
		{
			s.reportError(errUnterminatedCharLit, tokBegin, tokLine)
			tbag.push(tokUnspec, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	}

angledString:

	{
		var yych byte
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '\n':
			fallthrough
		case '\r':
			goto yy48
		case '>':
			goto yy49
		case '\\':
			goto yy50
		default:
			if pos < 0 || pos >= len(buf) {
				goto yy52
			}
			goto yy46
		}
	yy46:
		pos++
	yy47:
		{
			goto angledString
		}
	yy48:
		pos++
		{
			s.reportError(errUnterminatedAString, tokBegin, tokLine)
			tbag.push(tokUnterminatedAString, tokBegin, pos-1, tokLine, s)
			pos--
			goto acceptToken
		}
	yy49:
		pos++
		{
			tbag.push(tokAString, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	yy50:
		pos++
		yych = 0
		if pos < 0 || pos >= len(buf) {
			s, buf, pos, yych = yypeek(s, len(buf))
		} else {
			yych = buf[pos]
		}
		switch yych {
		case '>':
			goto yy51
		default:
			goto yy47
		}
	yy51:
		pos++
		{
			goto angledString
		}
	yy52:
		{
			s.reportError(errUnterminatedAString, tokBegin, tokLine)
			tbag.push(tokUnterminatedAString, tokBegin, pos, tokLine, s)
			goto acceptToken
		}
	}

}

//go:noinline
func yypeek(s *Scanner, softEnd int) (*Scanner, string, int, byte) {
	// Note: no callee-save registers, roundtripping Scanner to avoid
	// spills in caller
	s.prevSoftEnd = softEnd
	for {
		pos := skipLineCont(s.input, softEnd)
		if pos == softEnd {
			break
		}
		s.line++
		softEnd = nextLineContOrEnd(s.input, pos)
		if pos != softEnd {
			return s, s.input[:softEnd], pos, s.input[pos]
		}
	}
	return s, s.input, len(s.input), 0
}
